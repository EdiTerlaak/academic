---
title: Do Schools Discriminate against Night Owls? Evidence from Count Models (part 1)
author: Edi Terlaak
date: '2021-05-11'
slug: do-schools-discriminate-against-night-owls-evidence-from-count-models
categories: []
tags: []
subtitle: ''
summary: ''
authors: []
lastmod: '2021-05-11T13:42:04+02:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---



<p>A widely shared belief is that some people naturally rise early while others prosper during the night. To be precise, the belief is that this behavior is not induced by the environment, but is the expression of an innate biological clock. Researchers have captured this phenomenon with questionnaires and given it a scientific name. Instead of early birds and night owls, they speak of ‘early’ and ‘late’ chronotypes respectively.</p>
<p>According to <a href="https://www.nature.com/articles/s41598-017-04076-y">recent research</a> published in Nature by Giulia Zerbini and others, late chronotypes suffer from the early start of school. In the Netherlands, a school day starts on average at 8:30, when late chronotypes have barely booted up. Based on their research, Zerbini and colleagues go as far as saying that “early school starting times are a form of discrimination against late chronotypes.” (p. 7)</p>
<p>They do so based on their analysis of the impact of chronotype on absenteeism and grades. We deal with absenteeism in this post and the next, which leads us into the realm of count models. We are able to do so because the researchers have made their data available in an exemplary way <a href="https://dataverse.nl/dataset.xhtml?persistentId=doi:10.34894/HH2U2H">here</a>.</p>
<p>After taking a brief look at these data, we start thinking about how we should model it. We first come up with a natural starting point and then look for other models and adjustments, based on the nature of the lack of model fit.</p>
<div id="the-data" class="section level2">
<h2>The Data</h2>
<p>The data were collected at a school in Coevorden, the Netherlands among students in the age range 11 - 16. Among the 523 students selected for the study, 426 filled in the chronotype questionnaire. Of the 20 classes in the study, 12 were HAVO (intermediate/high level) and 8 VWO (highest level). The lowest level (VMBO) was absent then. The authors do not justify this selection decision. It may well inflate a possible effect however. Earlier work, that is cited in the Zerbini article, shows that late chronotypes do worse on fluid intelligence tasks in the morning. Higher levels like HAVO and VWO presumably make greater demands on fluid intelligence, so that the impact of chronotype could be felt more severely at HAVO and VWO.</p>
<p>When we load the data set, we note that there are 440 observations. Among this subset, roughly 1% of the data is missing.</p>
<pre class="r"><code>library(naniar)
library(tidyverse)
library(MASS)
library(pscl)
library(patchwork)
library(broom)
library(forcats)

setwd(&quot;C:/R/edu/chronotypes&quot;)
att &lt;- read_tsv(&quot;MCTQ_and_attendance.txt&quot;) 
att %&gt;% miss_var_summary() </code></pre>
<pre><code>## # A tibble: 11 x 3
##    variable                     n_miss pct_miss
##    &lt;chr&gt;                         &lt;int&gt;    &lt;dbl&gt;
##  1 MSF_sc                           14    3.18 
##  2 MSFsc groups 1-7                 14    3.18 
##  3 SJL                              14    3.18 
##  4 LA 1st 2013-2014                  2    0.455
##  5 Removed 2013-2014                 2    0.455
##  6 Sick frequency 2013-2014          2    0.455
##  7 Sick duration 2013-2014           2    0.455
##  8 SD_w                              1    0.227
##  9 all student IDs for HAVO-VWO      0    0    
## 10 age                               0    0    
## 11 sex                               0    0</code></pre>
<p>Given that we have no information about the 523 - 440 = 83 students that are not in this data set but were selected for the study, together with the small number of missing data, the benefit of missing data imputation is not worth the effort. So we won’t bother.</p>
<p>Let us describe the 11 variables in the data set so that we know what was actually measured. Columns 2 to 5 contain the response variables being late for class, being removed from class, the number of times a student is sick and the duration a students is sick. Then the background variables sex and age are stored, after which we get four measures related to chronotype. The main assumption with regard to these measures is that individuals have a personal biological clock, which is revealed in the weekend (or work free days to be precise) - when they supposedly go to bed and wake up at their ‘natural’ points in time. A correction is made for sleep debt that individuals accumulated during the work week or school week. Let’s run through the four variables.</p>
<ul>
<li><code>SD_w</code> is the average sleep duration on school days</li>
<li><code>MSF_sc</code> is the midpoint between sleep onset and sleep end on free days (MSF stands for Mid-Sleep on Free days), corrected for sleep need</li>
<li><code>MSFsc groups 1-7</code> turns the <code>MSF_sc</code> into an ordinal variable with seven classes</li>
<li><code>SJL</code> stand for social jetlag, and is calculated as the absolute difference between the midpoint of sleep times between school days and free days</li>
</ul>
<p>Let’s quichly inspect the variables with histograms.</p>
<pre class="r"><code># write a function that makes a hist per var
plot_for_loop &lt;- function(df, x_var) {
    ggplot(df, aes(x = .data[[x_var]])) + 
      geom_histogram()
}
# stick the col names of att into the function via map, and so make a list of plots
plot_list &lt;- colnames(att)[-1] %&gt;% 
  map( ~ plot_for_loop(att, .x))

wrap_plots(plot_list)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>We go through some initial observations. First, the response variables are counts with lots of zeros, which we will have to deal with in the analysis. We furthermore note that the average sleep duration <code>SD_W</code> on school days is left skewed, but that most students report that they sleep between 7 and 9 hours. The midpoint of the supposed natural sleep cycle of a student is around 4 AM, while the social jet lag seems quite large at around 2 hours on average.</p>
<p>If we plot social jet lag against the mid point of natural sleep <code>MSF_sc</code> we see that the two variables are not perfectly correlated. Why not? Do students not all start at the same time?</p>
<pre class="r"><code># SJL vs MSF_sc
ggplot(att, aes(x=MSF_sc, y=SJL)) + 
  geom_point() + 
  ggtitle(&quot;Social jetlag and the midpoint of sleep on free days&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<p>The likely reason is that students have different travel times to school and different preparation time more generally before school start.</p>
<p>Note also that students who have their natural midpoint of sleep at 2 AM have no or only a little social jet lag. There is one night owl with a natural midpoint of sleep of 8 AM with a massive social jet lag of 6 hours. On the other end of the spectrum, we have one early bird with a natural mid point around midnight, who suffers 3.5 hours of social jet lag (recall that social jet lag is an absolute measure). We do not have the filled in questionnaire, but there was supposedly no reason to doubt the validity of this response. In any case, the early bird is more of an outlier than the night owl.</p>
<p>Another interesting relation is the one between the midpoint of sleep <code>MSF_sc</code> and the number of hours sleep on a school day <code>SW_w</code>.</p>
<pre class="r"><code>ggplot(att, aes(x=MSF_sc, y=SD_w)) + 
  geom_point() +
  ggtitle(&quot;Hours sleep on school day and midpoint of sleep&quot;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-4-1.png" width="672" /></p>
<p>Unsurprisingly, students with a later onset of the natural sleep cycle sleep less during school days. Less obvious is the increasing variation in hours slept as we move rightward to later chronotypes. Some late chronotypes seem to be able to adjust and get their hours of sleep, while other can’t adjust. It would be interesting to investigate what the determinants of coping are. This question is practically relevant as well, because adjusting personal sleeping behavior is less dramatic than changing school times. But that requires another data set.</p>
<p>For now, the challenge is to estimate the effect of chronotype on the response variables regarding absenteeism, for which we turn to count models.</p>
</div>
<div id="count-models" class="section level2">
<h2>Count Models</h2>
<p>What we want to explain here are counts of being late, being sick or being dismissed. The structure of the situation is such that each count is the result of a sequence of 0 or 1 events.
Take the count of being sick. There are 189 legally required school days in the Netherlands (I assume the school in Coevorden stuck with this minimum). For every day, a student is either called in sick or not. (We assume a student is not sick twice a day.) The PMF that models these situations is the binomial distribution, with mean <span class="math inline">\(np\)</span> and variance <span class="math inline">\(\sqrt{np(1-p)}\)</span>. This should therefore be our starting point.</p>
<p>That means that we shouldn’t automatically start modeling with the Poisson, just because we have count data. The Poisson is built for situations in which events are counted in continuous time or space. See this <a href="https://www.youtube.com/watch?v=jsqSScywvMc">video</a> by John Tsitsiklis for a refresher. If there were no limit on the number of times a student can be sick per day and his parent can call in on every moment of the day, then the Poisson would be the appropriate first choice. But that is not the case.</p>
<p>That being said, if the number of failures is much higher than the number of successes, then we can use the Poisson to approximate the binomial. In fact, as n goes to infinity and p goes to 0, then the binomial becomes the Poisson - see <a href="https://youtu.be/TD1N4hxqMzY?t=1378">here</a> for a derivation.</p>
<p>For the three cases discussed here, n is 189 for being sick <em>per day</em>, while it is about 1253 for both being late and for being dismissed <em>from class</em> (I assumed a class is 45 minutes and used that HAVO takes 4700 clock hours in a 5 year total). The Poisson approximation is more reasonable then for the latter two cases.</p>
<p>Below we run through a sequence of count models to hopefully fit the data and the data generating process ever better.</p>
<div id="binomial-and-quasi-binomial-regression" class="section level3">
<h3>Binomial and Quasi-binomial regression</h3>
<p>We start with the most natural model, which treats the events as discrete sequences of success and failure. We apply it first to the case of days sick, to get familiar with the <code>glm</code> function and its summary in R. We do not know the precise sequence of 0’s and 1’s, so we feed the count of successes (as days sick) and failures into the binomial regression model. We choose <code>MSF_sc</code> as this variables is the most valid measure of chronotype (while the others are heavily correlated) as well as age and sex.</p>
<pre class="r"><code># add the counts of successes and failures to the data set
att_compl &lt;- att %&gt;% mutate(not_sick = 189 - `Sick frequency 2013-2014`,
                            on_time = 1253 - `LA 1st 2013-2014`,
                            not_removed = 1253 - `Removed 2013-2014`,
                            sick_cols = cbind(`Sick frequency 2013-2014`,not_sick),
                            late_cols = cbind(`LA 1st 2013-2014`,on_time),
                            rem_cols = cbind(`Removed 2013-2014`,not_removed),
                            sex = as.factor(sex),
                            `MSFsc groups 1-7`=as.factor(`MSFsc groups 1-7`),
                            sex = fct_recode(sex, &quot;female&quot; = &quot;0&quot;, &quot;male&quot; = &quot;1&quot;))  %&gt;%
                                  relocate(`Sick frequency 2013-2014`, 
                                           `LA 1st 2013-2014`, 
                                           `Removed 2013-2014`)

# run a binomial regression on the proportion
bin &lt;- glm(att_compl$sick_cols ~ age + sex + MSF_sc, data = att_compl, family = &#39;binomial&#39;)
summary(bin)</code></pre>
<pre><code>## 
## Call:
## glm(formula = att_compl$sick_cols ~ age + sex + MSF_sc, family = &quot;binomial&quot;, 
##     data = att_compl)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -2.6541  -1.8660  -0.6204   0.6183  11.2383  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept) -5.63875    0.43187 -13.056  &lt; 2e-16 ***
## age          0.06485    0.03429   1.891 0.058570 .  
## sexmale     -0.22702    0.06421  -3.536 0.000407 ***
## MSF_sc       0.12625    0.02983   4.232 2.31e-05 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 1293.1  on 423  degrees of freedom
## Residual deviance: 1256.7  on 420  degrees of freedom
##   (16 observations deleted due to missingness)
## AIC: 2139.7
## 
## Number of Fisher Scoring iterations: 5</code></pre>
<p>We get a table with coefficients for the intercept and the covariates in our model. Besides them are standard errors, which do not overwhelm the estimates. We leave the interpretation of the coefficients for later, because they don’t mean much if the model doesn’t fit.</p>
<p>We then read: “Dispersion parameter for binomial family taken to be 1”. We discussed the dispersion parameter <span class="math inline">\(\phi\)</span> in this <a href="https://www.editerlaak.nl/post/fundamentals-2-generalized-linear-models/">post</a> about the GLM. In the logistical model we take this parameter to be 1. We may adjust it later.</p>
<p>Below this line, we read about Null deviance and Residual deviance. These are a bunch of big numbers with degrees of freedom attached to them. What do they mean?</p>
<p>Loosely speaking, deviance is the analogue of the sum of squares for a linear model. Taking the sum of squared residuals could technically be done for a GLM-type model, but is computationally less efficient than maximum likelihood. We stay within the likelihood framework here then, where the deviance compares the likelihood of two models.</p>
<p>More technically, the deviance is a log-likelihood ratio of two models, which must be nested. The ratio is multiplied by 2 so that it should follow a Chi-Squared distribution with mean equal to the appropriate degrees of freedom (df of overarching model - df of the nested model).</p>
<p>Looking at the formulas is the fastest way of getting intuition. Below, LL stands for log likelihood and df for degrees of freedom.</p>
<ul>
<li><span class="math inline">\(Null\ Deviance = 2(LL(Saturated\ Model) - LL(Null\ Model))\)</span>
with df = df_Sat - df_Null</li>
<li><span class="math inline">\(Residual\ Deviance = 2(LL(Saturated\ Model) - LL(Proposed\ Model))\)</span>
with df = df_Sat - df_Proposed</li>
</ul>
<p>In both formulas, stuff is subtracted from the Saturated Model. This model is the one where there is a parameter for every data point. Presumably, this is the best that can be done. The Null model on the other hand has only one parameter (so no covariates), while the Proposed model has four in our case.</p>
<p>The Null deviance subtracts the log likelihood of the Null model from the Saturated model. If nothing remains, we can stop using the model. We won’t be able to do better than using the single parameter that the Null model uses.</p>
<p>The Residual deviance subtracts the log likelihood of the Proposed model from the Saturated one. We want these numbers to be close together. The closer we are to the Saturated number the better, after all. So we want the Residual Deviance to be small.</p>
<p>So what does the Residual deviance in the output above tell us about the fit of our model? Well, it is about 3 times as big as the degrees of freedom (and hence as the mean of the accompanying Chi-Squared distribution). Given the number of observations, we don’t need a test to see that the model doesn’t fit the data well. So there surely is a lot of unexplained variance. This could be due to a lack of covariates in our model, but of that we can never be sure. Or it could be due to dependence between successes: they could come in clusters.</p>
<p>A solution for the last scenario is to allows for a dispersion parameter &gt; 1, so that the variance of the Binomial is scaled. This is called the quasi-binomial model, which leads us out of the exponential family and into the realm of quasi-likelihood theory. We will not delve into that here, but note merely that the estimates of the coefficients are the same as in the binomial model. Only the standard error is increased.</p>
<p>Before we do so, we inspect the coefficients together with their standard error for all three response variables.</p>
<pre class="r"><code># function that takes in data and family and spits out a list with model info
glm_model &lt;- function(explan, fam){glm(explan ~ age + sex + MSF_sc, 
                                       data = att_compl, 
                                       family = fam)
}

# Loop models, already include quasibinomial to save work later
models &lt;-list()
for (i in 15:17){
  models[[i-14]] &lt;- glm_model(att_compl[[i]], &quot;binomial&quot;)
  models[[i-11]] &lt;- glm_model(att_compl[[i]], &quot;quasibinomial&quot;)
}

# create a tibble that organizes key data into a table
table_bin &lt;- tibble(terms = c(&quot;intercept&quot;, &quot;age&quot;, &quot;sex&quot;, &quot;MSF_sc&quot;), &quot;coef sick&quot; = rep(NA,4),
                    &quot;se sick&quot; = rep(NA,4),&quot;coef late&quot;=rep(NA,4),&quot;se late&quot;=rep(NA,4),
                    &quot;coef removed&quot;=rep(NA,4),&quot;se removed&quot; =rep(NA,4))

# loop such that the data is organized intelligible
for (i in 1:3){
  table_bin[,(2*i)] &lt;- summary(models[[i]])$coefficients[,1]
  table_bin[,2*i+1] &lt;- summary(models[[i]])$coefficients[,2]
}
# print
table_bin </code></pre>
<pre><code>## # A tibble: 4 x 7
##   terms  `coef sick` `se sick` `coef late` `se late` `coef removed` `se removed`
##   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;
## 1 inter~     -5.64      0.432      -12.6      0.665         -8.89         0.853 
## 2 age         0.0648    0.0343       0.364    0.0514        -0.0630       0.0672
## 3 sex        -0.227     0.0642       0.165    0.0992         1.04         0.142 
## 4 MSF_sc      0.126     0.0298       0.117    0.0446         0.331        0.0491</code></pre>
<p>Most coefficients are not overwhelmed by their standard errors. Again, this doesn’t guarantee that we have built a well-specified model though. Let’s look at all the residual deviance scores for starters.</p>
<pre class="r"><code>res_bin &lt;- tibble(&quot;sick model&quot; = NA, &quot;late model&quot; = NA, &quot;removed model&quot; = NA)

# loop such that the data is organized intelligible
for (i in 1:3){
  res_bin[,i] &lt;- summary(models[[i]])$deviance
}
res_bin</code></pre>
<pre><code>## # A tibble: 1 x 3
##   `sick model` `late model` `removed model`
##          &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt;
## 1        1257.         755.            711.</code></pre>
<p>All three models have 420 df (they use the same three covariates), so there are problems with model fit for all three models. Let’s build some intuition by turning the counts into proportions and fitting the binomial models. This reveals that binomial regression is a lot like logistic regression (which is binomial regression with 1 trial), but that we now have proportions to work with instead of 0’s and 1’s.</p>
<pre class="r"><code># add proportions to the data set
att_compl_prop &lt;- att_compl %&gt;% mutate(prop_sick = `Sick frequency 2013-2014`/189,
                                  prop_late = `LA 1st 2013-2014`/1253,
                                  prop_removed = `Removed 2013-2014`/1253)

# plot binomial for all three proportions
bin_plot &lt;- function(prop, distr, ylab){att_compl_prop %&gt;% 
    ggplot(aes(x=MSF_sc, y=prop)) +
    geom_jitter(alpha=0.3) +
    geom_smooth(method = &#39;glm&#39;, method.args = list(family=distr), color=&quot;pink&quot;) +
    ylab(ylab) +
    xlab(&quot;chronotype&quot;)  + 
    xlim(c(1.5,8))
}

bpl_s &lt;- bin_plot(att_compl_prop[[18]], &#39;binomial&#39;,&quot;prop days sick&quot;) +
  ylim(c(0,0.1)) 
bpl_l &lt;- bin_plot(att_compl_prop[[19]], &#39;binomial&#39;,&quot;prop late for class&quot;)+
  ylim(c(0,0.01))
bpl_r &lt;- bin_plot(att_compl_prop[[20]], &#39;binomial&#39;,&quot;prop removed&quot;)+
  ylim(c(0,0.01)) 

binom_plot &lt;- bpl_s + bpl_l + bpl_r 

binom_plot + plot_annotation(
  title = &quot;Binomial regression for absentee data&quot;
)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-8-1.png" width="672" /></p>
<p>Note that the confidence interval band is much wider for the first model on days sick. This is because the n is much smaller for this model. We also observe that there seems to be a lot more variance in the data than than the model accounts for.</p>
<p>Although we get a better idea for what the model is doing, it is hard to evaluate model fit from these plots. To end we first look at the residuals directly by simulating from the model and comparing the results with the actual outcomes. See my post on <a href="https://www.editerlaak.nl/post/nuts-and-bolts-1-ml-and-ols/">maximum likelihood</a> for background on simulation. Here, we will for convenience sake ignore the uncertainty in the estimation of the coefficients and only simulate the uncertainty in the stochastic component of the model. We run the three model 100 times each, and compare the simulated distribution of days sick with the observations.</p>
<pre class="r"><code># check model fit by simulation
# simulation without uncertainty in coefficients
bin_sims &lt;- list()
for (i in 1:3){
k &lt;- 100
bin_sims[[i]] &lt;- as_tibble(replicate(k, 
                                  rbinom(rep(1, 
                                         length(predict(models[[i]], type = &#39;response&#39;) )), 
                                         ifelse(i&lt;2, 189, 1253), 
                                         predict(models[[i]], type = &#39;response&#39;) ))) %&gt;% 
  pivot_longer(cols = everything(), names_to = &quot;iteration&quot;) 
}


sim_bin_s &lt;- ggplot() + 
  geom_line(data=bin_sims[[1]], aes(x=value, group=iteration), stat=&quot;density&quot;, alpha = 0.1) +
  geom_density(data=att_compl, aes(x=`Sick frequency 2013-2014`), color=&quot;#C91585&quot;) +  
  geom_text(aes(x = -0.5, y = 0.2, label = &quot;data&quot;), color=&quot;#C91585&quot;)  +
  geom_text(aes(x = 5, y = 0.15, label = &quot;model runs&quot;)) +
  scale_x_continuous(name =&quot;number of days sick&quot;, 
                     limits=c(-1,8),
                     breaks = seq(0,12,2))
sim_bin_l &lt;- ggplot() + 
  geom_line(data=bin_sims[[2]], aes(x=value, group=iteration), stat=&quot;density&quot;, alpha = 0.1) +
  geom_density(data=att_compl, aes(x=`LA 1st 2013-2014`), color=&quot;#C91585&quot;) +
  scale_x_continuous(name =&quot;late for class count&quot;, 
                     limits=c(-1,8),
                     breaks = seq(0,12,2))
sim_bin_r &lt;- ggplot() + 
  geom_line(data=bin_sims[[3]], aes(x=value, group=iteration), stat=&quot;density&quot;, alpha = 0.1) +
  geom_density(data=att_compl, aes(x=`Removed 2013-2014`), color=&quot;#C91585&quot;) +
  scale_x_continuous(name =&quot;removed from class count&quot;, 
                     limits=c(-1,8),
                     breaks = seq(0,12,2))

sim_b_patch &lt;- sim_bin_s / (sim_bin_l + sim_bin_r)

sim_b_patch + plot_annotation(
  title = &quot;Simulations from binomial model for all absentee variables&quot;
)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>Note first that the variable is a count and thus discrete. We use smooth functions though, because it allows us to show multiple model runs. We also note that the number or zeros is badly underestimated by all the model runs, as are high counts in the tail. This must mean that the model overestimates the amount of moderate numbers, which can indeed be seen in the graphs.</p>
<p>To look at residuals from another point of view, we plot the standardized residuals against the explanatory variables (this arguably gives more insight than plotting against the predictions).</p>
<pre class="r"><code># drop NA&#39;s so that row lengths match; dplyr &#39;select&#39; conflicts with MASS &#39;select&#39;
att_drop &lt;- att_compl %&gt;% dplyr::select(`Sick frequency 2013-2014`:not_removed) %&gt;% drop_na()

## plot residuals
resid_x &lt;- list()
for (i in 1:3){
resid_x[[i]] &lt;- tibble(y_hat = ifelse(i &lt; 2, 
                                           models[[i]]$fitted.values*189,
                                           models[[i]]$fitted.values*1253),
                            residual = models[[i]]$residuals, 
                            MSF = att_drop$MSF_sc,
                            age = att_drop$age,
                            sex = att_drop$sex,
                            stand_resid = (residual-mean(residual))/sd(residual)) 
} 

plot_resid &lt;- function(resp_var, x_val){
  resid_x[[resp_var]] %&gt;% 
    ggplot(aes(x=get(x_val), y=stand_resid)) +
    geom_jitter(width=0.1, alpha=0.2) +
    geom_hline(yintercept=0, color=&quot;springgreen&quot;, size=0.5) +
    ylab(&quot;stand residual&quot;)
} 

p1 &lt;- plot_resid(1,&quot;MSF&quot;) + xlab(&quot;chronotype score&quot;) + xlim(c(1.5,9))
p2 &lt;- plot_resid(1,&quot;age&quot;) + xlab(&quot;age&quot;)
p3 &lt;- plot_resid(1, &quot;sex&quot;) + xlab(&quot;sex&quot;)

patch &lt;- p1 / (p2 + p3) 

patch + plot_annotation(
  title = &quot;Standardized residuals of days sick model&quot;,
  subtitle = &quot;By explanatory variable&quot;
)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<p>We observe from these graphs that the distribution of residuals is cut off from below. This is as expected, since the observed counts are restricted below by 0. Hence, we see residuals clumped together just below the green lines everywhere. There are no clear patterns in the spread of residuals that can be glanced from these graphs.</p>
<p>The same picture appears for the late for class model (and the removed from class model, which is not shown here).</p>
<pre class="r"><code>## same for the response var &#39;late in class&#39;
p4 &lt;- plot_resid(2,&quot;MSF&quot;) + xlab(&quot;chronotype&quot;) + xlim(c(1.5,9))
p5 &lt;- plot_resid(2,&quot;age&quot;) + xlab(&quot;age&quot;)
p6 &lt;- plot_resid(2, &quot;sex&quot;) + xlab(&quot;sex&quot;)

patch &lt;- p4 / (p5 + p6) 

patch + plot_annotation(
  title = &quot;Standardized residuals of late for class model&quot;,
  subtitle = &quot;By explanatory variable&quot;
)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>We observe that the model has too many residuals that are too big. The variance is higher in reality than the model accounts for. We already knew this by looking at the residual deviance. We say in such cases that the model is overdispersed. If so, we have a fix at our disposal, which is quasibinomial regression. This model adds a dispersion parameter <span class="math inline">\(\omega\)</span> &gt; 1 (it was set to 1 in the standard binomial regression) so that more of the variance is accounted for. As we already fitted the quasibinomial models in earlier code, we can check the model fit right away.</p>
<pre class="r"><code>disp_qbin &lt;- tibble(&quot;sick model&quot; = NA, &quot;late model&quot; = NA, &quot;removed model&quot; = NA)

# loop such that the data is organized intelligible
for (i in 4:6){
  disp_qbin[,i-3] &lt;- summary(models[[i]])$dispersion
}
disp_qbin</code></pre>
<pre><code>## # A tibble: 1 x 3
##   `sick model` `late model` `removed model`
##          &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt;
## 1         3.70         1.96            2.36</code></pre>
<p>We note that the dispersion is higher than one for all three response variables. It makes sense then to account for the extra variance in the model. This has consequences for the standard errors.</p>
<pre class="r"><code># create a tibble that organizes key data into a table
table_qbin &lt;- tibble(terms = c(&quot;intercept&quot;, &quot;age&quot;, &quot;sex&quot;, &quot;MSF_sc&quot;), &quot;coef sick&quot; = rep(NA,4),
                    &quot;se sick&quot; = rep(NA,4),&quot;coef late&quot;=rep(NA,4),&quot;se late&quot;=rep(NA,4),
                    &quot;coef removed&quot;=rep(NA,4),&quot;se removed&quot; =rep(NA,4))

# loop such that the data is organized intelligible
for (i in 1:3){
  table_qbin[,(2*i)] &lt;- summary(models[[i+3]])$coefficients[,1]
  table_qbin[,2*i+1] &lt;- summary(models[[i+3]])$coefficients[,2]
}
# print
table_qbin </code></pre>
<pre><code>## # A tibble: 4 x 7
##   terms  `coef sick` `se sick` `coef late` `se late` `coef removed` `se removed`
##   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;
## 1 inter~     -5.64      0.831      -12.6      0.931         -8.89         1.31  
## 2 age         0.0648    0.0660       0.364    0.0719        -0.0630       0.103 
## 3 sex        -0.227     0.124        0.165    0.139          1.04         0.218 
## 4 MSF_sc      0.126     0.0574       0.117    0.0625         0.331        0.0753</code></pre>
<p>For the days sick model, standard errors have doubled, while they also increased strongly for the other models. In some cases <code>age</code>and <code>sex</code> estimates have now been overwhelmed by their SE’s, but not <code>MSF_sc</code>.</p>
<p>Given the unsatisfying fit for even the model with the response with the lowest number of trials (days sick), we will give Poisson models a shot.</p>
</div>
<div id="poisson-and-quasi-poisson-regression" class="section level3">
<h3>Poisson and Quasi-Poisson regression</h3>
<p>Let’s start with some basics of the Poisson. It’s PMF is given by</p>
<p><span class="math display">\[\Pr[X = x] = e^{-\lambda} \frac{\lambda^x}{x!}, \quad x = 0, 1, 2, \ldots.\]</span>
The distribution has only one parameter, which is <span class="math inline">\(\lambda\)</span>. Famously, it is equal to both the expected value as well the variance. See <a href="https://youtu.be/TD1N4hxqMzY?t=370">this video</a> for derivations of the basic properties by the great Joe Blitzstein.</p>
<p>We want to model the central parameter <span class="math inline">\(\lambda\)</span> with a linear equation, and we use the canonical link for the Poisson, which is the log.</p>
<p><span class="math display">\[log(\lambda (x))=\beta_0+\beta_1x\]</span></p>
<p>This leads to the following likelihood model.</p>
<p><span class="math display">\[L(\beta_0,\beta_1;y_i)=\prod_{i=1}^{n}\frac{e^{-\lambda{(x_i)}}[\lambda(x_i)]^{y_i}}{y_i!}=\prod_{i=1}^{n}\frac{e^{-e^{(\beta_0+\beta_1x_i)}}\left [e^{(\beta_0+\beta_1x_i)}\right ]^{y_i}}{y_i!}\]</span></p>
<p>Taking the log gives the log-likelihood, which allows us to write the function with sums instead of products and gets rid of most of the the stacked exponentials as well.</p>
<p><span class="math display">\[l(\beta_0,\beta_1;y_i)=-\sum_{i=1}^n e^{(\beta_0+\beta_1x_i)}+\sum_{i=1}^ny_i (\beta_0+\beta_1x_i)-\sum_{i=1}^n\log(y_i!) \tag{1}\]</span>
Not all rare events are Poisson distributed of course. For a data generating process to be Poisson, the events that may lead to a count must be independent (or at most ‘weakly dependent’) and, as we mentioned, the mean and variance <span class="math inline">\(\lambda\)</span> must be equal.</p>
<p>We run a poisson <code>glm</code> and inspect the output of summary.</p>
<pre class="r"><code>## Attendance with poisson 
fit_poiss &lt;- glm(`Sick frequency 2013-2014` ~ MSF_sc + age + sex, data=att, family=poisson)
summary(fit_poiss)</code></pre>
<pre><code>## 
## Call:
## glm(formula = `Sick frequency 2013-2014` ~ MSF_sc + age + sex, 
##     family = poisson, data = att)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -2.6425  -1.8623  -0.6161   0.6131  10.9067  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept) -0.39281    0.42894  -0.916 0.359793    
## MSF_sc       0.12453    0.02961   4.206  2.6e-05 ***
## age          0.06399    0.03405   1.879 0.060208 .  
## sex         -0.22410    0.06379  -3.513 0.000443 ***
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## (Dispersion parameter for poisson family taken to be 1)
## 
##     Null deviance: 1270.3  on 423  degrees of freedom
## Residual deviance: 1234.4  on 420  degrees of freedom
##   (16 observations deleted due to missingness)
## AIC: 2122.9
## 
## Number of Fisher Scoring iterations: 5</code></pre>
<p>Because the residual deviance is again a lot bigger than the degrees of freedom, we may again be dealing with overdispersion. (The same is true for the other response variables.) Looking at the Poisson regression curve through the data points reveals that we shouldn’t be too surprised by this lack of fit.</p>
<pre class="r"><code>plot_poiss &lt;- function(y_var) {
  att_compl %&gt;% ggplot(aes(x=MSF_sc, y=.data[[y_var]])) + 
    geom_jitter() +
    geom_smooth(method = &#39;glm&#39;, method.args = list(family=&#39;poisson&#39;), color=&quot;pink&quot;) +
    ylim(c(0,16)) +
    xlim(c(1.5,8.5))
}
# stick the col names of att into the function via map, and so make a list of plots
plot_list &lt;- colnames(att_compl)[1:3] %&gt;% 
  map( ~ plot_poiss(.))

wrap_plots(plot_list) + plot_annotation(
  title = &quot;Poisson regression for absentee data&quot;
)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>The dispersion parameters of the quasipoisson confirm our hunch.</p>
<pre class="r"><code># Loop poisson models
p_models &lt;-list()
for (i in 1:3){
  p_models[[i]] &lt;- glm_model(att_compl[[i]], &quot;poisson&quot;)
  p_models[[i+3]] &lt;- glm_model(att_compl[[i]], &quot;quasipoisson&quot;)
}

disp_qp &lt;- tibble(&quot;sick model&quot; = NA, &quot;late model&quot; = NA, &quot;removed model&quot; = NA)

# loop such that the data is organized intelligible
for (i in 4:6){
  disp_qp[,i-3] &lt;- summary(models[[i]])$dispersion
}
disp_qp</code></pre>
<pre><code>## # A tibble: 1 x 3
##   `sick model` `late model` `removed model`
##          &lt;dbl&gt;        &lt;dbl&gt;           &lt;dbl&gt;
## 1         3.70         1.96            2.36</code></pre>
<p>And so we use the quasi-poisson to estimate the standard error of our estimates.</p>
<pre class="r"><code>## SE&#39;s and est
table_qp &lt;- tibble(terms = c(&quot;intercept&quot;, &quot;age&quot;, &quot;sex&quot;, &quot;MSF_sc&quot;), &quot;coef sick&quot; = rep(NA,4),
                   &quot;se sick&quot; = rep(NA,4),&quot;coef late&quot;=rep(NA,4),&quot;se late&quot;=rep(NA,4),
                   &quot;coef removed&quot;=rep(NA,4),&quot;se removed&quot; =rep(NA,4))

# loop such that the data is organized intelligible
for (i in 1:3){
  table_qp[,(2*i)] &lt;- summary(models[[i+3]])$coefficients[,1]
  table_qp[,2*i+1] &lt;- summary(models[[i+3]])$coefficients[,2]
}
# print
table_qp </code></pre>
<pre><code>## # A tibble: 4 x 7
##   terms  `coef sick` `se sick` `coef late` `se late` `coef removed` `se removed`
##   &lt;chr&gt;        &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;     &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;
## 1 inter~     -5.64      0.831      -12.6      0.931         -8.89         1.31  
## 2 age         0.0648    0.0660       0.364    0.0719        -0.0630       0.103 
## 3 sex        -0.227     0.124        0.165    0.139          1.04         0.218 
## 4 MSF_sc      0.126     0.0574       0.117    0.0625         0.331        0.0753</code></pre>
<p>Simulating from the Poisson shows that the model deviates from the response data for days sick in very much the same way as for the binomial.</p>
<pre class="r"><code>p_sims &lt;- list()
for (i in 1:3){
  k &lt;- 100
  p_sims[[i]] &lt;- as_tibble(replicate(k, 
                                       rpois(nrow(att_compl), exp(predict(p_models[[i]])) ))
                             ) %&gt;% 
    pivot_longer(cols = everything(), names_to = &quot;iteration&quot;) 
}

plot_p &lt;- function(dat, x_var, plotname) {ggplot() + 
  geom_line(data=dat, aes(x=value, group=iteration), stat=&quot;density&quot;, alpha = 0.1) +
  geom_density(data=att_compl, aes(x=x_var), color=&quot;#C91585&quot;) +  
  scale_x_continuous(name =plotname, 
                     limits=c(-1,8),
                     breaks = seq(0,12,2))
}

sim_p_s &lt;- plot_p(p_sims[[1]], att_compl$`Sick frequency 2013-2014`, &quot;number of days sick&quot;) +
  geom_text(aes(x = -0.5, y = 0.2, label = &quot;data&quot;), color=&quot;#C91585&quot;)  +
  geom_text(aes(x = 5, y = 0.15, label = &quot;model runs&quot;)) 
  
  
sim_p_l &lt;- plot_p(p_sims[[2]], att_compl$`LA 1st 2013-2014`, &quot;late for class count&quot;) 
  

sim_p_r &lt;- plot_p(p_sims[[3]], att_compl$`Removed 2013-2014`, &quot;removed from class count&quot;) 
  
sim_p_patch &lt;- sim_p_s / (sim_p_l + sim_p_r)

sim_p_patch + plot_annotation(
  title = &quot;Simulations from Poisson model&quot;
)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<p>If n gets bigger and p smaller, then the Poisson becomes an ever better approximation to the binomial. We don’t really see that in the simulation though.</p>
<p>Let us look at the errors a little more closely. If the standardized residuals are following a Normal distribution, we wouldn’t be that concerned about the fit of our model. There is noise around our model curve, but the noise would cancel out. If the residuals deviate from normality we start to worry about our model.</p>
<pre class="r"><code>plot_dist_p &lt;- function(tib){ ggplot() + 
    geom_density(data=as_tibble(tib), aes(x=value), color=&quot;pink&quot;) +
    stat_function(fun = dnorm, 
                  n = 400, 
                  args = list(mean = 0, sd = 1), 
                  color=&quot;grey&quot;,
                  linetype = &quot;dashed&quot;) +
    xlim(c(-6,6))
}

std_pois &lt;- list()
y_p &lt;- data.frame()
y_hat_p &lt;- list()
p_dist_plot &lt;- list()
p_dist_tib &lt;- tibble()
for (i in 1:3){
  y_p &lt;- att_compl[,i] %&gt;% drop_na()
  y_hat_p[i] &lt;- p_models[[i]]$fitted.values 
  std_pois[i] &lt;- y_p-p_models[[i]]$fitted.values/sqrt(mean(p_models[[i]]$fitted.values))
  
}

c &lt;- map(std_pois, plot_dist_p)
pp1 &lt;- c[[1]] + xlab(&quot;days sick&quot;) +
         geom_text(aes(x = 2, y = 0.3, label = &quot; standard normal&quot;), color=&quot;grey&quot;) +
         geom_text(aes(x = 5, y = 0.03, label = &quot;stand residuals&quot;), color=&quot;pink&quot;) 
pp2 &lt;- c[[2]] + xlab(&quot;late for class&quot;) 
pp3 &lt;- c[[3]] + xlab(&quot;removed from class&quot;)
patch_dist_p &lt;- pp1 + pp2 + pp3
patch_dist_p + plot_annotation(
  title=&quot;Deviations of standardized residuals from the Standard Normal&quot;
)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<p>These graphs tell the same story as the residual plots for the binomial. The model overshoots more than we expect. We also note that the late for class and removed from class models, which have more trials, suffer less from this problem. The spikes to the left of zero of the Standard Normal are probably caused by the last two models missing the large amount of zeros in the data.</p>
<p>We therefore move on to the negative-binomial and zero-inflated models in the next post.</p>
</div>
</div>
